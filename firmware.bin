/*
 Combined ESP32 firmware:
 - WiFi connect
 - Fetch config from server (/config/<deviceId>)
   (reads secondsToRead and optional firmwareUrl)
 - HTTP OTA (auto via config, manual via "ota" serial or ws command)
 - HX711 reading + interactive serial calibration ('c')
 - Secure WebSocket sending JSON readings periodically
*/

#include <WiFi.h>
#include <HTTPClient.h>
#include <Update.h>
#include <ArduinoJson.h>
#include <WebSocketsClient.h>
#include <HX711.h>

WiFiClientSecure *otaSecureClient = nullptr; // for https requests (allocated inside function)
HTTPClient otaHttp;      

// ---------------- WIFI CONFIG ----------------
const char* ssid = "DK";
const char* password = "yourname";

// ---------------- SERVER CONFIG ----------------
const char* websocket_host = "weighing-server.onrender.com";
const uint16_t websocket_port = 443;
const char* websocket_path = "/";

const char* http_host_base = "https://weighing-server.onrender.com";  // used for config API

// ---------------- HX711 CONFIG ----------------
#define DT 5   // HX711 Data pin (DOUT)
#define SCK 4  // HX711 Clock pin (SCK)
HX711 scale;

float calibration_factor = -13.40335;  // initial guess — re-calibrate on device

// ---------------- GLOBALS ----------------
WebSocketsClient webSocket;
String deviceId;
unsigned long lastSend = 0;
unsigned long SECONDS_TO_READ = 1000;  // ms, updated from server
bool websocketConnected = false;

unsigned long lastConfigFetch = 0;
const unsigned long CONFIG_FETCH_INTERVAL = 5UL * 60UL * 1000UL; // every 5 minutes
unsigned long lastOTACheck = 0;
const unsigned long OTA_CHECK_INTERVAL = 30UL * 60UL * 1000UL; // every 30 minutes

// ---- Device ID from ESP32 MAC ----
String generateDeviceId() {
  uint64_t chipid = ESP.getEfuseMac();
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X",
          (uint8_t)(chipid >> 40),
          (uint8_t)(chipid >> 32),
          (uint8_t)(chipid >> 24),
          (uint8_t)(chipid >> 16),
          (uint8_t)(chipid >> 8),
          (uint8_t)chipid);
  return "XYID-X3G-V2-AA(" + String(macStr) + ")";
}



#define MAX_REDIRECTS 5
#define OTA_READ_TIMEOUT_MS 8000  // wait up to 8s between data bursts

bool performHttpOTA(String firmwareUrl) {
  Serial.println("Starting OTA from: " + firmwareUrl);

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected — cannot OTA");
    return false;
  }

  #ifdef ESP32
  Serial.printf("Free sketch space: %u bytes\n", ESP.getFreeSketchSpace());
  #endif

  String url = firmwareUrl;
  int redirectCount = 0;
  int httpCode = -1;

  // follow redirects (http / https)
  while (redirectCount < MAX_REDIRECTS) {
    // clean previous client if any
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }

    if (url.startsWith("https://")) {
      otaSecureClient = new WiFiClientSecure();
      otaSecureClient->setInsecure(); // NOTE: replace with cert pinning in production
      if (!otaHttp.begin(*otaSecureClient, url)) {
        Serial.println("otaHttp.begin(https) failed");
        if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
        return false;
      }
    } else {
      if (!otaHttp.begin(url)) {
        Serial.println("otaHttp.begin(http) failed");
        return false;
      }
    }

    otaHttp.setTimeout(20000); // 20s timeout for slower connections
    Serial.println("HTTP GET -> " + url);
    httpCode = otaHttp.GET();
    Serial.printf("HTTP code: %d\n", httpCode);

    if (httpCode == HTTP_CODE_OK) {
      break; // good
    } else if (httpCode == HTTP_CODE_MOVED_PERMANENTLY || httpCode == HTTP_CODE_FOUND ||
               httpCode == HTTP_CODE_SEE_OTHER || httpCode == 307 || httpCode == 308) {
      String newLocation = otaHttp.header("Location");
      Serial.println("Redirected to: " + newLocation);
      otaHttp.end();
      if (newLocation.length() == 0) {
        Serial.println("Redirect without Location header - aborting");
        if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
        return false;
      }
      url = newLocation;
      redirectCount++;
      continue;
    } else {
      Serial.printf("OTA HTTP GET failed, code=%d\n", httpCode);
      otaHttp.end();
      if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
      return false;
    }
  } // redirect loop

  if (httpCode != HTTP_CODE_OK) {
    Serial.println("Too many redirects or final GET failed.");
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  int contentLength = otaHttp.getSize();
  Serial.printf("OTA: contentLength=%d\n", contentLength);
  if (contentLength <= 0) {
    Serial.println("Content-Length missing/zero — aborting OTA.");
    otaHttp.end();
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  // prepare Update
  if (!Update.begin((uint32_t)contentLength)) {
    Serial.printf("Update.begin failed: %s\n", Update.errorString());
    otaHttp.end();
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  WiFiClient * stream = otaHttp.getStreamPtr();
  const size_t BUFSZ = 512;
  uint8_t buff[BUFSZ];
  size_t written = 0;
  unsigned long lastRead = millis();

  Serial.println("Receiving firmware...");

  while (written < (size_t)contentLength) {
    int avail = stream->available();
    if (avail <= 0) {
      if (millis() - lastRead > OTA_READ_TIMEOUT_MS) {
        Serial.println("Timeout waiting for stream data — aborting OTA");
        break;
      }
      delay(5);
      continue;
    }

    int toRead = avail;
    if (toRead > (int)BUFSZ) toRead = BUFSZ;
    int r = stream->readBytes(buff, toRead);
    if (r <= 0) {
      Serial.printf("stream read returned %d — aborting\n", r);
      break;
    }

    // write with small retries
    size_t w = 0;
    const int MAX_WRITE_RETRIES = 2;
    int attempt;
    for (attempt = 0; attempt <= MAX_WRITE_RETRIES; ++attempt) {
      w = Update.write(buff, r);
      if (w == (size_t)r) break;
      Serial.printf("Attempt %d: Update.write returned %u (expected %d)\n", attempt+1, (unsigned)w, r);
      Serial.printf("Update.errorString(): %s\n", Update.errorString());
      delay(50);
    }

    if (w != (size_t)r) {
      Serial.printf("Write mismatch after retries: wrote %u expected %d — aborting OTA\n", (unsigned)w, r);
      Serial.printf("Final Update.errorString(): %s\n", Update.errorString());
      Update.abort();
      otaHttp.end();
      if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
      return false;
    }

    written += w;
    lastRead = millis();
    Serial.printf("OTA progress: %u/%d bytes (%.1f%%)\n", (unsigned)written, contentLength, (written*100.0)/contentLength);
  }

  // final checks
  if (written != (size_t)contentLength) {
    Serial.printf("OTA written size mismatch (%u != %d) — aborting\n", (unsigned)written, contentLength);
    Update.abort();
    otaHttp.end();
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  if (!Update.end()) {
    Serial.printf("Update.end() failed: %s\n", Update.errorString());
    otaHttp.end();
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  if (!Update.isFinished()) {
    Serial.println("Update not finished — aborting");
    otaHttp.end();
    if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
    return false;
  }

  Serial.println("OTA complete — restarting");
  otaHttp.end();
  if (otaSecureClient) { delete otaSecureClient; otaSecureClient = nullptr; }
  delay(100);
  ESP.restart();
  return true;
}


// ---- Fetch Config from Server ----
// Server response example expected:
// { "secondsToRead": 1000, "firmwareUrl": "https://server/firmware.bin" }
String lastFirmwareUrl = "";

void fetchConfig() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected — skipping fetchConfig");
    return;
  }

  HTTPClient http;
  String url = String(http_host_base) + "/config/" + deviceId;
  Serial.println("Fetching config: " + url);

  http.begin(url);
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    Serial.println("Config payload: " + payload);

    StaticJsonDocument<512> doc;
    DeserializationError err = deserializeJson(doc, payload);
    if (!err) {
      unsigned long sec = doc["secondsToRead"] | SECONDS_TO_READ;
      SECONDS_TO_READ = sec;
      Serial.printf("Updated SECONDS_TO_READ = %lu ms\n", SECONDS_TO_READ);

      if (doc.containsKey("firmwareUrl")) {
        String fw = doc["firmwareUrl"].as<String>();
        if (fw.length() > 0 && fw != lastFirmwareUrl) {
          Serial.println("New firmwareUrl in config: " + fw);
          lastFirmwareUrl = fw;
          // perform OTA immediately when server pushes new URL
          performHttpOTA(fw);
        }
      }
    } else {
      Serial.println("Failed to parse config JSON");
    }
  } else {
    Serial.printf("Failed to fetch config, HTTP code=%d\n", httpCode);
  }

  http.end();
}

// ---- WebSocket Handler ----
void webSocketEvent(WStype_t type, uint8_t* payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      websocketConnected = false;
      Serial.println("[WSc] Disconnected");
      break;
    case WStype_CONNECTED:
      websocketConnected = true;
      Serial.printf("[WSc] Connected to: %s\n", payload ? (char*)payload : "");
      {
        // send hello identification
        String hello = "{\"deviceId\":\"" + deviceId + "\",\"event\":\"hello\"}";
        webSocket.sendTXT(hello);
      }
      break;
    case WStype_TEXT: {
      String msg = String((char*)payload).substring(0, length);
      Serial.printf("[WSc] RX text: %s\n", msg.c_str());

      // Try parse JSON commands from server e.g., {"event":"ota","url":"https://..."}
      StaticJsonDocument<512> doc;
      DeserializationError err = deserializeJson(doc, msg);
      if (!err && doc.containsKey("event")) {
        String ev = doc["event"].as<String>();
        if (ev == "ota" && doc.containsKey("url")) {
          String fw = doc["url"].as<String>();
          if (fw.length() > 0) {
            Serial.println("WebSocket requested OTA to: " + fw);
            performHttpOTA(fw);
          }
        } else if (ev == "cfg") {
          // server asked to refresh config
          fetchConfig();
        }
      }
      break;
    }
    case WStype_BIN:
      Serial.printf("[WSc] RX %u bytes (binary)\n", (unsigned)length);
      break;
    default:
      break;
  }
}

// ---- Interactive calibration via Serial ----
void doCalibrationInteractive() {
  Serial.println(F("\n=== Calibration procedure ==="));
  Serial.println(F("1) Remove all weight from scale, then press Enter to tare."));
  while (!Serial.available()) { delay(10); }
  // flush and read line
  while (Serial.available()) Serial.read();
  delay(200);
  scale.tare(20);
  Serial.println("Tared. Now place the known weight on the scale.");
  Serial.println("2) After placing the known weight, enter the weight in grams (e.g., 1000) and press Enter.");

  // wait for numeric input
  String s = "";
  while (true) {
    if (Serial.available()) {
      String in = Serial.readStringUntil('\n');
      in.trim();
      if (in.length() == 0) continue;
      s = in;
      break;
    }
    delay(10);
  }

  float knownGrams = s.toFloat();
  if (knownGrams <= 0) {
    Serial.println("Invalid weight entered. Aborting calibration.");
    return;
  }

  scale.set_scale(1.0);
  delay(200);
  float measured = scale.get_units(10);  // average of 10 readings
  Serial.printf("Measured (temporary scale 1.0) = %.3f units\n", measured);

  if (fabs(measured) < 1e-6) {
    Serial.println("Measured value too small or zero — check wiring and load cell.");
    return;
  }

  float new_cal = measured / knownGrams;
  scale.set_scale(new_cal);
  calibration_factor = new_cal;

  Serial.println(F("Calibration complete."));
  Serial.printf("New calibration_factor = %.6f\n", calibration_factor);
  Serial.println(F("If reported weights are negative, multiply calibration factor by -1."));
  Serial.println(F("Persist this calibration_factor in your code if desired."));
  Serial.println(F("==============================\n"));
}

// ---- WiFi connect helper ----
void connectWiFi() {
  Serial.print("Connecting to WiFi");
  WiFi.begin(ssid, password);
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
    // After 20 seconds try reconnecting
    if (millis() - start > 20000) {
      Serial.println("\nRetrying WiFi connect...");
      WiFi.disconnect();
      WiFi.begin(ssid, password);
      start = millis();
    }
  }
  Serial.println("\n✅ WiFi connected");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

void setup() {
  Serial.begin(115200);
  delay(300);

  esp_reset_reason_t reason = esp_reset_reason();
  Serial.printf("Reset reason: %d\n", reason); // optional debug

  // Generate device ID early
  deviceId = generateDeviceId();
  Serial.println("Device ID: " + deviceId);

  // ---------------- WiFi ----------------
  connectWiFi();

  // ---------------- HX711 ----------------
  scale.begin(DT, SCK);
  scale.set_scale(calibration_factor);
  scale.tare();  // reset scale to 0
  Serial.println("HX711 ready. Type 'c' in Serial to run calibration sequence.");
  Serial.printf("Using calibration_factor = %.6f\n", calibration_factor);

  // ---------------- Fetch Config ----------------
  fetchConfig();
  lastConfigFetch = millis();

  // ---------------- WebSocket ----------------
  // open secure websocket (wss)
  // Note: webSocket.beginSSL needs the host, port, path
  webSocket.beginSSL(websocket_host, websocket_port, websocket_path);
  webSocket.onEvent(webSocketEvent);
  webSocket.setReconnectInterval(5000);  // ms

  Serial.println("Setup complete.");
  lastSend = millis();
  lastOTACheck = millis();
}

void loop() {
  webSocket.loop();

  // Periodically fetch config from server
  if (millis() - lastConfigFetch >= CONFIG_FETCH_INTERVAL) {
    fetchConfig();
    lastConfigFetch = millis();
  }

  // Periodically check if config requested OTA via lastFirmwareUrl (re-check server for new URL)
  if (millis() - lastOTACheck >= OTA_CHECK_INTERVAL) {
    Serial.println("Periodic OTA check (fetching config)...");
    fetchConfig();
    lastOTACheck = millis();
  }

  // Serial commands handling
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    if (line == "c" || line == "C") {
      doCalibrationInteractive();
    } else if (line == "cfg") {
      fetchConfig();
    } else if (line == "ota") {
      if (lastFirmwareUrl.length() > 0) {
        Serial.println("Manual OTA using lastFirmwareUrl: " + lastFirmwareUrl);
        performHttpOTA(lastFirmwareUrl);
      } else {
        Serial.println("No firmwareUrl known from config. Use 'cfg' to fetch config or provide an https URL.");
      }
    } else if (line.startsWith("ota ")) {
      // manual ota with url: ota https://...
      String url = line.substring(4);
      url.trim();
      if (url.length() > 0) {
        performHttpOTA(url);
      } else Serial.println("Usage: ota <firmware_url>");
    } else if (line.length() > 0) {
      Serial.printf("Unknown command: %s\n", line.c_str());
      Serial.println("Commands: c -> calibrate, cfg -> fetch config, ota -> manual OTA (or 'ota <url>')");
    }
  }

  // Send readings periodically
  if (millis() - lastSend >= SECONDS_TO_READ) {
    lastSend = millis();

    float grams = scale.get_units(10);  // average of 10 readings; after calibration this should be grams
    float kg = grams / 1000.0;

    if (isnan(grams)) {
      Serial.println("⚠ HX711 reading failed (NaN)");
    } else {
      // Prepare JSON payload
      StaticJsonDocument<256> doc;
      doc["deviceId"] = deviceId;
      // round grams to 2 decimals
      float grams_round = round(grams * 100.0) / 100.0;
      float kg_round = round(kg * 1000.0) / 1000.0;

      doc["grams"] = grams_round;
      doc["kg"] = kg_round;
      doc["weight"] = kg_round;
      doc["calibrationFactor"] = calibration_factor;
      String json;
      serializeJson(doc, json);

      // Send via websocket if connected
      if (websocketConnected) {
        webSocket.sendTXT(json);
        Serial.printf("TX JSON: %s\n", json.c_str());
      } else {
        Serial.println("WebSocket not connected — not sending. Will retry.");
      }

      // Print local debug
      Serial.printf("Grams: %.2f\tKg: %.3f\n", grams_round, kg_round);
    }
  }

  // small delay to yield
  delay(10);
}
