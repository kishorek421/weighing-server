/*
 Combined ESP32 firmware:
 - WiFi connect
 - Fetch config from server (/config/<deviceId>)
   (reads secondsToRead and optional firmwareUrl)
 - HTTP OTA (auto via config, manual via "ota" serial or ws command)
 - HX711 reading + interactive serial calibration ('c')
 - Secure WebSocket sending JSON readings periodically
*/

#include <WiFi.h>
#include <HTTPClient.h>
#include <Update.h>
#include <ArduinoJson.h>
#include <WebSocketsClient.h>
#include <HX711.h>

// ---------------- WIFI CONFIG ----------------
const char* ssid = "DK";
const char* password = "yourname";

// ---------------- SERVER CONFIG ----------------
const char* websocket_host = "weighing-server.onrender.com";
const uint16_t websocket_port = 443;
const char* websocket_path = "/";

const char* http_host_base = "https://weighing-server.onrender.com";  // used for config API

// ---------------- HX711 CONFIG ----------------
#define DT 5   // HX711 Data pin (DOUT)
#define SCK 4  // HX711 Clock pin (SCK)
HX711 scale;

float calibration_factor = 13.40335;  // initial guess — re-calibrate on device

// ---------------- GLOBALS ----------------
WebSocketsClient webSocket;
String deviceId;
unsigned long lastSend = 0;
unsigned long SECONDS_TO_READ = 1000;  // ms, updated from server
bool websocketConnected = false;

unsigned long lastConfigFetch = 0;
const unsigned long CONFIG_FETCH_INTERVAL = 5UL * 60UL * 1000UL; // every 5 minutes
unsigned long lastOTACheck = 0;
const unsigned long OTA_CHECK_INTERVAL = 30UL * 60UL * 1000UL; // every 30 minutes

// ---- Device ID from ESP32 MAC ----
String generateDeviceId() {
  uint64_t chipid = ESP.getEfuseMac();
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X",
          (uint8_t)(chipid >> 40),
          (uint8_t)(chipid >> 32),
          (uint8_t)(chipid >> 24),
          (uint8_t)(chipid >> 16),
          (uint8_t)(chipid >> 8),
          (uint8_t)chipid);
  return "XYID-X3G-V2-AA(" + String(macStr) + ")";
}

// ---- Helper: perform HTTP OTA given a URL ----
bool performHttpOTA(const String &firmwareUrl) {
  Serial.println("Starting OTA from: " + firmwareUrl);

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected — cannot OTA");
    return false;
  }

  HTTPClient http;

  // Note: If you need strict TLS, replace the next line with:
  // WiFiClientSecure client;
  // client.setInsecure(); // or setFingerprint(...)
  // http.begin(client, firmwareUrl);
  http.begin(firmwareUrl);

  int httpCode = http.GET();
  if (httpCode != HTTP_CODE_OK) {
    Serial.printf("OTA HTTP GET failed, code=%d\n", httpCode);
    http.end();
    return false;
  }

  int contentLength = http.getSize();
  String contentType = http.header("Content-Type");
  Serial.printf("OTA: contentLength=%d, contentType=%s\n", contentLength, contentType.c_str());

  if (contentLength <= 0) {
    Serial.println("Content-Length not provided or zero — cannot OTA (needs fixed length).");
    http.end();
    return false;
  }

  // get stream for writing to Update
  WiFiClient * stream = http.getStreamPtr();

  if (!Update.begin(contentLength)) {
    Serial.println("Not enough space to begin OTA");
    http.end();
    return false;
  }

  size_t written = Update.writeStream(*stream);

  if (written != (size_t)contentLength) {
    Serial.printf("OTA written size mismatch (%u != %d)\n", (unsigned)written, contentLength);
    Update.abort();
    http.end();
    return false;
  }

  if (!Update.end()) {
    Serial.printf("OTA failed finishing: %s\n", Update.errorString());
    http.end();
    return false;
  }

  if (Update.isFinished()) {
    Serial.println("OTA Success — restarting");
    http.end();
    delay(100);
    ESP.restart();
    return true; // won't reach, but for completeness
  } else {
    Serial.println("OTA not finished? unknown error");
    http.end();
    return false;
  }
}

// ---- Fetch Config from Server ----
// Server response example expected:
// { "secondsToRead": 1000, "firmwareUrl": "https://server/firmware.bin" }
String lastFirmwareUrl = "";

void fetchConfig() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected — skipping fetchConfig");
    return;
  }

  HTTPClient http;
  String url = String(http_host_base) + "/config/" + deviceId;
  Serial.println("Fetching config: " + url);

  http.begin(url);
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    Serial.println("Config payload: " + payload);

    StaticJsonDocument<512> doc;
    DeserializationError err = deserializeJson(doc, payload);
    if (!err) {
      unsigned long sec = doc["secondsToRead"] | SECONDS_TO_READ;
      SECONDS_TO_READ = sec;
      Serial.printf("Updated SECONDS_TO_READ = %lu ms\n", SECONDS_TO_READ);

      if (doc.containsKey("firmwareUrl")) {
        String fw = doc["firmwareUrl"].as<String>();
        if (fw.length() > 0 && fw != lastFirmwareUrl) {
          Serial.println("New firmwareUrl in config: " + fw);
          lastFirmwareUrl = fw;
          // perform OTA immediately when server pushes new URL
          performHttpOTA(fw);
        }
      }
    } else {
      Serial.println("Failed to parse config JSON");
    }
  } else {
    Serial.printf("Failed to fetch config, HTTP code=%d\n", httpCode);
  }

  http.end();
}

// ---- WebSocket Handler ----
void webSocketEvent(WStype_t type, uint8_t* payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      websocketConnected = false;
      Serial.println("[WSc] Disconnected");
      break;
    case WStype_CONNECTED:
      websocketConnected = true;
      Serial.printf("[WSc] Connected to: %s\n", payload ? (char*)payload : "");
      {
        // send hello identification
        String hello = "{\"deviceId\":\"" + deviceId + "\",\"event\":\"hello\"}";
        webSocket.sendTXT(hello);
      }
      break;
    case WStype_TEXT: {
      String msg = String((char*)payload).substring(0, length);
      Serial.printf("[WSc] RX text: %s\n", msg.c_str());

      // Try parse JSON commands from server e.g., {"event":"ota","url":"https://..."}
      StaticJsonDocument<512> doc;
      DeserializationError err = deserializeJson(doc, msg);
      if (!err && doc.containsKey("event")) {
        String ev = doc["event"].as<String>();
        if (ev == "ota" && doc.containsKey("url")) {
          String fw = doc["url"].as<String>();
          if (fw.length() > 0) {
            Serial.println("WebSocket requested OTA to: " + fw);
            performHttpOTA(fw);
          }
        } else if (ev == "cfg") {
          // server asked to refresh config
          fetchConfig();
        }
      }
      break;
    }
    case WStype_BIN:
      Serial.printf("[WSc] RX %u bytes (binary)\n", (unsigned)length);
      break;
    default:
      break;
  }
}

// ---- Interactive calibration via Serial ----
void doCalibrationInteractive() {
  Serial.println(F("\n=== Calibration procedure ==="));
  Serial.println(F("1) Remove all weight from scale, then press Enter to tare."));
  while (!Serial.available()) { delay(10); }
  // flush and read line
  while (Serial.available()) Serial.read();
  delay(200);
  scale.tare(20);
  Serial.println("Tared. Now place the known weight on the scale.");
  Serial.println("2) After placing the known weight, enter the weight in grams (e.g., 1000) and press Enter.");

  // wait for numeric input
  String s = "";
  while (true) {
    if (Serial.available()) {
      String in = Serial.readStringUntil('\n');
      in.trim();
      if (in.length() == 0) continue;
      s = in;
      break;
    }
    delay(10);
  }

  float knownGrams = s.toFloat();
  if (knownGrams <= 0) {
    Serial.println("Invalid weight entered. Aborting calibration.");
    return;
  }

  scale.set_scale(1.0);
  delay(200);
  float measured = scale.get_units(10);  // average of 10 readings
  Serial.printf("Measured (temporary scale 1.0) = %.3f units\n", measured);

  if (fabs(measured) < 1e-6) {
    Serial.println("Measured value too small or zero — check wiring and load cell.");
    return;
  }

  float new_cal = measured / knownGrams;
  scale.set_scale(new_cal);
  calibration_factor = new_cal;

  Serial.println(F("Calibration complete."));
  Serial.printf("New calibration_factor = %.6f\n", calibration_factor);
  Serial.println(F("If reported weights are negative, multiply calibration factor by -1."));
  Serial.println(F("Persist this calibration_factor in your code if desired."));
  Serial.println(F("==============================\n"));
}

// ---- WiFi connect helper ----
void connectWiFi() {
  Serial.print("Connecting to WiFi");
  WiFi.begin(ssid, password);
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
    // After 20 seconds try reconnecting
    if (millis() - start > 20000) {
      Serial.println("\nRetrying WiFi connect...");
      WiFi.disconnect();
      WiFi.begin(ssid, password);
      start = millis();
    }
  }
  Serial.println("\n✅ WiFi connected");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

void setup() {
  Serial.begin(115200);
  delay(300);

  esp_reset_reason_t reason = esp_reset_reason();
  Serial.printf("Reset reason: %d\n", reason); // optional debug

  // Generate device ID early
  deviceId = generateDeviceId();
  Serial.println("Device ID: " + deviceId);

  // ---------------- WiFi ----------------
  connectWiFi();

  // ---------------- HX711 ----------------
  scale.begin(DT, SCK);
  scale.set_scale(calibration_factor);
  scale.tare();  // reset scale to 0
  Serial.println("HX711 ready. Type 'c' in Serial to run calibration sequence.");
  Serial.printf("Using calibration_factor = %.6f\n", calibration_factor);

  // ---------------- Fetch Config ----------------
  fetchConfig();
  lastConfigFetch = millis();

  // ---------------- WebSocket ----------------
  // open secure websocket (wss)
  // Note: webSocket.beginSSL needs the host, port, path
  webSocket.beginSSL(websocket_host, websocket_port, websocket_path);
  webSocket.onEvent(webSocketEvent);
  webSocket.setReconnectInterval(5000);  // ms

  Serial.println("Setup complete.");
  lastSend = millis();
  lastOTACheck = millis();
}

void loop() {
  webSocket.loop();

  // Periodically fetch config from server
  if (millis() - lastConfigFetch >= CONFIG_FETCH_INTERVAL) {
    fetchConfig();
    lastConfigFetch = millis();
  }

  // Periodically check if config requested OTA via lastFirmwareUrl (re-check server for new URL)
  if (millis() - lastOTACheck >= OTA_CHECK_INTERVAL) {
    Serial.println("Periodic OTA check (fetching config)...");
    fetchConfig();
    lastOTACheck = millis();
  }

  // Serial commands handling
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    if (line == "c" || line == "C") {
      doCalibrationInteractive();
    } else if (line == "cfg") {
      fetchConfig();
    } else if (line == "ota") {
      if (lastFirmwareUrl.length() > 0) {
        Serial.println("Manual OTA using lastFirmwareUrl: " + lastFirmwareUrl);
        performHttpOTA(lastFirmwareUrl);
      } else {
        Serial.println("No firmwareUrl known from config. Use 'cfg' to fetch config or provide an https URL.");
      }
    } else if (line.startsWith("ota ")) {
      // manual ota with url: ota https://...
      String url = line.substring(4);
      url.trim();
      if (url.length() > 0) {
        performHttpOTA(url);
      } else Serial.println("Usage: ota <firmware_url>");
    } else if (line.length() > 0) {
      Serial.printf("Unknown command: %s\n", line.c_str());
      Serial.println("Commands: c -> calibrate, cfg -> fetch config, ota -> manual OTA (or 'ota <url>')");
    }
  }

  // Send readings periodically
  if (millis() - lastSend >= SECONDS_TO_READ) {
    lastSend = millis();

    float grams = scale.get_units(10);  // average of 10 readings; after calibration this should be grams
    float kg = grams / 1000.0;

    if (isnan(grams)) {
      Serial.println("⚠ HX711 reading failed (NaN)");
    } else {
      // Prepare JSON payload
      StaticJsonDocument<256> doc;
      doc["deviceId"] = deviceId;
      // round grams to 2 decimals
      float grams_round = round(grams * 100.0) / 100.0;
      float kg_round = round(kg * 1000.0) / 1000.0;

      doc["grams"] = grams_round;
      doc["kg"] = kg_round;
      doc["weight"] = kg_round;
      doc["calibrationFactor"] = calibration_factor;
      String json;
      serializeJson(doc, json);

      // Send via websocket if connected
      if (websocketConnected) {
        webSocket.sendTXT(json);
        Serial.printf("TX JSON: %s\n", json.c_str());
      } else {
        Serial.println("WebSocket not connected — not sending. Will retry.");
      }

      // Print local debug
      Serial.printf("Grams: %.2f\tKg: %.3f\n", grams_round, kg_round);
    }
  }

  // small delay to yield
  delay(10);
}
